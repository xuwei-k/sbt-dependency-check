/*
 * Copyright 2025 the original author or authors
 *
 * SPDX-License-Identifier: MIT
 */

package net.nmoncho.sbt.dependencycheck.settings

import scala.jdk.CollectionConverters.*

import org.owasp.dependencycheck.dependency.Dependency
import org.owasp.dependencycheck.dependency.Vulnerability
import org.owasp.dependencycheck.utils.SeverityUtil
import sbt.Logger

/** Trait used to define how Summaries are generated after an analysis
  */
trait SummaryReport {

  /** Builds an analysis summary using the scanned dependencies and the failing CVSS Score
    *
    * @param dependencies scanned dependencies
    * @param failCvssScore failing CVSS Score
    * @return
    */
  def buildSummary(dependencies: Seq[Dependency], failCvssScore: Double): String

}

object SummaryReport {

  private final val NewLine = System.getProperty("line.separator", "\n").intern()

  /** Shows the summary to the console
    *
    * @param name project name
    * @param dependencies scanned dependencies
    * @param failCvssScore failing CVSS Score
    * @param report report type
    * @param log logger
    */
  def showSummary(
      name: String,
      dependencies: Seq[Dependency],
      failCvssScore: Double,
      report: SummaryReport
  )(
      implicit log: Logger
  ): Unit = {
    val summary = report.buildSummary(dependencies, failCvssScore)

    log.warn(
      s"\n\nOne or more dependencies were identified with known vulnerabilities in [$name]:\n\n${summary}" +
        "\n\nSee the dependency-check report for more details.\n\n"
    )
  }

  /** Gets the score of a given [[Vulnerability]], if exists
    */
  private def getScore(vulnerability: Vulnerability): Option[Double] =
    Option(vulnerability.getCvssV2)
      .map[Double](_.getCvssData.getBaseScore)
      .orElse(
        Option(vulnerability.getCvssV3).map[Double](_.getCvssData.getBaseScore)
      )
      .orElse(
        Option(vulnerability.getUnscoredSeverity).map[Double](SeverityUtil.estimateCvssV2)
      )

  /** Processes dependencies to be included in the report
    *
    * @param dependencies scanned dependencies
    * @param reportVulnerability predicate to define if a [[Vulnerability]] should be shown or not in the summary
    * @param summary [[StringBuilder]] used for aggregating the report
    */
  private def dependencyProcessor(
      dependencies: Seq[Dependency],
      reportVulnerability: (Vulnerability, Double) => Boolean,
      failCvssScore: Double,
      summary: StringBuilder
  ): Unit =
    dependencies.foreach { dependency =>
      if (!dependency.getVulnerabilities.isEmpty) {
        val formattedVulnerabilities =
          dependency.getVulnerabilities(true).asScala.flatMap { vulnerability =>
            getScore(vulnerability)
              .filter(reportVulnerability(vulnerability, _))
              .map(score =>
                if (score >= failCvssScore) {
                  s"${scala.Console.YELLOW}${vulnerability.getName()}${scala.Console.RESET} (${scala.Console.YELLOW}${score}${scala.Console.RESET})"
                } else {
                  s"${vulnerability.getName()} (${score})"
                }
              )
          }

        if (formattedVulnerabilities.nonEmpty) {
          summary
            .append(dependency.getFileName)
            .append(": ")

          summary.append(
            formattedVulnerabilities.mkString(", ")
          )

          summary.append(NewLine)
        }
      }
    }

  /** Original summary generated by Owasp DependencyCheck
    *
    * See [[org.owasp.dependencycheck.agent.DependencyCheckScanAgent.showSummary]]
    */
  object Original extends SummaryReport {

    override def buildSummary(dependencies: Seq[Dependency], failCvssScore: Double): String = {
      val summary = StringBuilder.newBuilder

      dependencies.foreach { d =>
        val ids = d.getVulnerabilities(true).asScala.map(_.getName).mkString(", ")

        if (ids.nonEmpty) {
          summary.append(d.getFileName).append("( ")
          summary.append(
            (d.getSoftwareIdentifiers.asScala ++ d.getVulnerableSoftwareIdentifiers.asScala)
              .map(_.getValue)
              .mkString(", ")
          )
          summary.append("): ").append(ids).append(NewLine)
        }
      }

      summary.toString()
    }

  }

  /** Shows all vulnerabilities in the summary with their corresponding score, whether they are an
    * offending vulnerability or not.
    */
  object AllVulnerabilities extends SummaryReport {

    override def buildSummary(dependencies: Seq[Dependency], failCvssScore: Double): String = {
      val summary = StringBuilder.newBuilder

      dependencyProcessor(dependencies, (_, _) => true, failCvssScore, summary)

      summary.toString()
    }

  }

  /** Shows only offending vulnerabilities in the summary with their corresponding score.
    */
  object OffendingVulnerabilities extends SummaryReport {

    override def buildSummary(dependencies: Seq[Dependency], failCvssScore: Double): String = {
      val summary = StringBuilder.newBuilder

      dependencyProcessor(
        dependencies,
        (_, score) => score >= failCvssScore,
        failCvssScore,
        summary
      )

      summary.toString()
    }

  }

}
